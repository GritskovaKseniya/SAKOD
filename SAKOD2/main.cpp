//Lab2List.cpp
/*
Цель:Реализация эффективного алгоритма сортировки слиянием
Автор:Грицкова К.А.
Дата: 12.02.2019
*/
#include <stdio.h>
#include <cstdlib>
#include<ctime>
#include <iostream>

using namespace std;

// Функция сортировки двухпутевым слиянием
//передаем ссылку на массив а и значение размера массива
void merge(int *a, int n)
{
    int mid = n / 2; // находим середину сортируемой последовательности
    if (n % 2 == 1) /*если число элементов в массиве не делится на цело
        то к целой части переменной mid прибавляем 1 и считаем это серединой */
        mid++;
    int h = 1; // шаг
// выделяем память под формируемую последовательность
int *c = (int*)malloc(n * sizeof(int));
int step; // объявление переменной step
//с помощью цикла формируем половину свормированной последовательности
while (h < n)
    {
        step = h;
        int i = 0; // индекс первого пути
        int j = mid; // индекс второго пути
        int k = 0; // индекс элемента в результирующей последовательности
        while (step <= mid)
            {
                while ((i < step) && (j < n) && (j < (mid + step)))
                    {
                        // пока не дошли до конца пути заполняем следующий элемент формируемой последовательности меньшим из двух просматриваемых
                        if (a[i] < a[j])
                        {
                            c[k] = a[i];
                            i++;
                            k++;
                        }
                        else
                            {
                                c[k] = a[j];
                                j++;
                                k++;
                            }
                    }
                    while (i < step)
                        {
                            // переписываем оставшиеся элементы первого пути (если второй кончился раньше)
                            c[k] = a[i];
                            i++;
                            k++;
                        }
                        while ((j < (mid + step)) && (j<n))
                            {
                                // переписываем оставшиеся элементы второго пути (если первый кончился раньше)
                                c[k] = a[j];
                                j++;
                                k++;
                            }
                        step = step + h; // переходим к следующему этапу
            }
h = h * 2;
// Переносим упорядоченную последовательность (промежуточный вариант) в исходный массив
for (i = 0; i<n; i++)
    a[i] = c[i];
     }
}

int main()
{
    srand(time(0));
    int a[8]; //создание массива из 8 элементов
    // Заполнение массива случайными числами
    for (int i = 0; i<8; i++)
        a[i] = rand() % 100;
    // Вывод элементов массива до сортировки
    for (int i = 0; i<8; i++)
        printf("%d ", a[i]);
        printf("\n");//перевод строки
        merge(a, 8); // вызов функции сортировки
        // Вывод элементов массива после сортировки
        for (int i = 0; i<8; i++)
            printf("%d ", a[i]); //цикл выводит все элементы массива по порядку
        printf("\n");//перевод строки
        getchar();
        return 0;
}
